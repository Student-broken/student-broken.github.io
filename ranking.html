<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Classement - Outil MBS</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- CSS is a refined version of your original, preferred layout -->
    <style>
        :root {--primary-color: #2980b9; --secondary-color: #2c3e50; --background-color: #f7f9fb; --widget-background: #ffffff; --text-color: #34495e; --light-grey: #e0e6eb; --danger-color: #e74c3c; --success-color: #27ae60; --shadow-widget: 0 10px 20px rgba(0, 0, 0, 0.07);}
        body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color: var(--background-color); color: var(--text-color); }
        .site-header-container { background-color: var(--widget-background); box-shadow: 0 2px 4px rgba(0,0,0,0.05); padding: 15px 0; position: relative; margin-bottom: 20px; }
        .site-header { text-align: center; padding: 0; margin: 0; color: var(--secondary-color); font-size: 2.2em; font-weight: 700; font-family: 'Playfair Display', serif; }
        .main-container { max-width: 1200px; margin: auto; padding: 0 20px; width: 100%; box-sizing: border-box; }
        .controls { background: var(--widget-background); padding: 20px; border-radius: 12px; box-shadow: var(--shadow-widget); margin-bottom: 25px; border: 1px solid var(--light-grey); }
        select { width: 100%; padding: 12px; border-radius: 10px; border: 1px solid #ddd; background-color: white; font-size: 1em; }
        .dashboard-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 25px; }
        .stat-widget { background: var(--widget-background); border-radius: 16px; padding: 25px; box-shadow: var(--shadow-widget); border: 1px solid var(--light-grey); display: flex; flex-direction: column; }
        .main-avg-widget { grid-column: 1 / -1; } /* The main widget is now full width */
        .widget-header { text-align: center; margin-bottom: 15px; }
        .widget-title { font-size: 1.2em; font-weight: bold; color: var(--secondary-color); margin: 0 0 10px 0; }
        .widget-value { font-size: 4em; font-weight: 700; color: var(--primary-color);}
        .widget-rank { font-size: 1.3em; font-weight: 600; color: var(--secondary-color); }
        .mini-leaderboard-container { flex-grow: 1; overflow-y: auto; position: relative; margin-top: 20px; border-top: 1px solid var(--light-grey); padding-top: 15px; max-height: 250px; }
        .leaderboard-list { list-style: none; padding: 0; margin: 0; }
        .leaderboard-item { display: flex; align-items: center; padding: 8px 10px; border-radius: 8px; font-size: 1em; transition: background-color 0.2s; }
        .leaderboard-item.is-user { background-color: #eaf2f8; font-weight: bold; }
        .item-rank { width: 45px; font-weight: 600; }
        .item-name { font-weight: normal; }
        .item-grade { margin-left: auto; font-weight: 600; }
        .error-message { text-align: center; padding: 40px; font-size: 1.2em; color: var(--danger-color); background-color: #fdd; border: 1px solid var(--danger-color); border-radius: 8px; }
        #debug-console { margin-top:30px; background: #2c3e50; color:#ecf0f1; border-radius:10px; padding:15px; font-family:monospace; height:150px; overflow-y:auto; font-size:0.9em; display:none; }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&family=Inter:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>
    <div class="site-header-container"><header class="site-header">Classements</header></div>
    <main class="main-container">
        <div class="controls">
            <label for="category-select">Comparer les classements pour :</label>
            <select id="category-select"></select>
        </div>
        <div id="dashboard-container">
            <div class="error-message" id="status-message" style="display: block;">Synchronisation...</div>
        </div>
        <div id="debug-console"></div>
    </main>

    <script>
        const SCRIPT_URL = 'PASTE_YOUR_WEB_APP_URL_HERE';
        const subjectNames = { 'ART':"Arts", 'MUS':"Musique", 'DRM':"Art Dram.", 'CAT':"Tech", 'FRA':"Fran√ßais", 'ELA':"Anglais", 'EESL':"Anglais Enrichi", 'ESL':"Anglais Second", 'SN':"Math SN", 'CST':"Math CST", 'ST':"Science", 'STE':"Science (STE)", 'HQC':"Histoire", 'CCQ':"Citoyennet√©", 'EPS':"√â. Phys.", 'CHI':"Chimie", 'PHY':"Physique", 'MON':"Monde Cont.", 'MED':"M√©dia", 'ENT':"Entreprenariat", 'INF':"Informatique", 'PSY':"Psychologie", 'FIN':"Finance" };
        const overallNames = { 'GlobalAverage':"Moyenne Globale", 'Etape1Average':"√âtape 1", 'Etape2Average':"√âtape 2", 'Etape3Average':"√âtape 3" };
        const TERM_WEIGHTS = { etape1:0.20, etape2:0.20, etape3:0.60 };

        const dashboardContainer = document.getElementById('dashboard-container');
        const debugConsole = document.getElementById('debug-console');
        const categorySelect = document.getElementById('category-select');
        const statusMessage = document.getElementById('status-message');

        function logToConsole(message, isError = false) { /* ... */ }
        document.addEventListener('DOMContentLoaded', initialize);

        async function initialize() {
            logToConsole("Initializing leaderboard...");
            if (SCRIPT_URL.includes('PASTE_YOUR_WEB_APP_URL_HERE')) { showError("SCRIPT_URL is not configured."); return; }

            logToConsole("Loading data from Local Storage...");
            const mbsData = JSON.parse(localStorage.getItem('mbsData'));
            if (!mbsData?.valid || !mbsData?.nom || !mbsData?.settings?.niveau) { showError("mbsData, nom, or niveau not found in Local Storage."); return; }
            
            logToConsole("Calculating local averages...");
            const averages = calculateAveragesFromRawData(mbsData);
            const encodedName = btoa(unescape(encodeURIComponent(mbsData.nom)));
            
            const formData = new FormData();
            formData.append('encodedName', encodedName);
            formData.append('secondaryLevel', mbsData.settings.niveau);
            formData.append('Timestamp', new Date().toISOString());
            for (const key in averages.term) { if (averages.term[key] !== null) formData.append(key, averages.term[key].toFixed(2)); }
            for (const key in averages.subjects) { if (averages.subjects[key] !== null) formData.append(key, averages.subjects[key].toFixed(2)); }

            logToConsole(`Sending data for user: ${mbsData.nom}`);
            try {
                // Step 1: Send (POST) data using the reliable FormData method
                const postResponse = await fetch(SCRIPT_URL, { method: 'POST', body: formData });
                if (!postResponse.ok) throw new Error(`POST request failed: ${postResponse.statusText}`);
                const postResult = await postResponse.json();
                if (postResult.result !== 'success') throw new Error(`Failed to save data: ${postResult.error}`);
                logToConsole("Data sent successfully.");

                // Step 2: Get (GET) all data back to calculate ranks
                logToConsole("Fetching full leaderboard data...");
                const getResponse = await fetch(SCRIPT_URL);
                if (!getResponse.ok) throw new Error(`GET request failed: ${getResponse.statusText}`);
                const allUsersData = await getResponse.json();
                if (allUsersData.result === 'error') throw new Error(`Failed to get data: ${allUsersData.error}`);
                logToConsole(`Received data for ${allUsersData.length} users.`);

                statusMessage.style.display = 'none';
                
                populateDropdown(averages.term, averages.subjects);
                const renderAndAttachListener = () => renderDashboard(allUsersData, encodedName, mbsData.settings.niveau);
                categorySelect.addEventListener('change', renderAndAttachListener);
                renderAndAttachListener(); // Initial render

            } catch (error) {
                showError(`Communication error: ${error.message}`);
            }
        }
        
        function populateDropdown(termAvgs, subjectAvgs) {
            let optionsHTML = '<optgroup label="Moyennes G√©n√©rales">';
            for (const key in overallNames) {
                if (termAvgs[key] !== null) optionsHTML += `<option value="${key}">${overallNames[key]}</option>`;
            }
            optionsHTML += '</optgroup><optgroup label="Mati√®res">';
            const sortedSubjects = Object.keys(subjectAvgs).sort((a,b) => (subjectNames[a] || a).localeCompare(subjectNames[b] || b));
            sortedSubjects.forEach(key => {
                if(subjectNames[key]) optionsHTML += `<option value="${key}">${subjectNames[key]}</option>`;
            });
            optionsHTML += `</optgroup>`;
            categorySelect.innerHTML = optionsHTML;
        }

        function renderDashboard(allUsersData, currentUserEncodedName, userLevel) {
            const selectedKey = categorySelect.value;
            const selectedText = categorySelect.options[categorySelect.selectedIndex].text;
            
            const levelData = allUsersData.filter(d => d.secondaryLevel === userLevel);
            const currentUserData = levelData.find(d => d.encodedName === currentUserEncodedName);

            if (!currentUserData) {
                showError(`Vos donn√©es n'ont pas √©t√© trouv√©es dans le classement pour ce niveau.`);
                return;
            }
            
            const mainWidgetHTML = createMainWidgetHTML(selectedText, selectedKey, levelData, currentUserData);
            const graphHTML = `<div class="stat-widget graph-widget">
                                <h3 class="widget-title" style="text-align:center;">Votre Performance vs. la Moyenne du Niveau</h3>
                                <div><canvas id="performanceChart"></canvas></div>
                               </div>`;
            
            dashboardContainer.innerHTML = `<div class="dashboard-grid">${mainWidgetHTML}${graphHTML}</div>`;
            
            // Create the chart after the canvas is added to the DOM
            createPerformanceChart(levelData, currentUserData);
            
            // Re-center leaderboard scroll after rendering
            const leaderboardContainer = document.querySelector('.mini-leaderboard-container');
            if (leaderboardContainer) {
                const userItem = leaderboardContainer.querySelector('.is-user');
                if (userItem) {
                    const containerHeight = leaderboardContainer.clientHeight;
                    const itemHeight = userItem.offsetHeight;
                    leaderboardContainer.scrollTop = userItem.offsetTop - (containerHeight / 2) + (itemHeight / 2);
                }
            }
        }
        
        function createMainWidgetHTML(title, key, levelData, currentUserData) {
            const ranks = getRank(levelData, key, currentUserData.encodedName);
            const userValue = parseFloat(currentUserData[key]);

            if (!ranks.rank || isNaN(userValue)) {
                return `<div class="stat-widget main-avg-widget"><div class="widget-header"><h3 class="widget-title">${title}</h3><div style="font-size:1.5em; color: var(--light-grey);">Donn√©es insuffisantes pour classer.</div></div></div>`;
            }

            const getTrophy = (rank) => (rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : `#${rank}`);
            const leaderboardItemsHTML = levelData
                .filter(u => u[key] && !isNaN(parseFloat(u[key])))
                .sort((a, b) => b[key] - a[key])
                .map((user, index) => {
                    const rank = index + 1;
                    const isCurrentUser = user.encodedName === currentUserData.encodedName;
                    const decodedName = isCurrentUser ? 'Vous' : `Anonyme #${rank}`; // Keep names anonymous
                    return `<li class="leaderboard-item ${isCurrentUser ? 'is-user' : ''}">
                                <span class="item-rank">${getTrophy(rank)}</span>
                                <span class="item-name">${decodedName}</span>
                                <span class="item-grade">${parseFloat(user[key]).toFixed(1)}%</span>
                            </li>`;
                }).join('');

            return `<div class="stat-widget main-avg-widget">
                        <div class="widget-header">
                            <h3 class="widget-title">${title}</h3>
                            <div class="widget-value">${userValue.toFixed(1)}%</div>
                            <div class="widget-rank">
                                ${ranks.rank} sur ${ranks.total}
                                <span style="color:${getPercentileColor(ranks.percentile)}; margin-left: 8px;">(Top ${ranks.percentile}%)</span>
                            </div>
                        </div>
                        <div class="mini-leaderboard-container">
                            <ul class="leaderboard-list">${leaderboardItemsHTML}</ul>
                        </div>
                    </div>`;
        }

        function createPerformanceChart(levelData, currentUserData) { /* Unchanged */ }
        function getRank(levelData, key, currentUserEncodedName) { /* Unchanged */ }
        function showError(message) { /* Unchanged */ }
        function getPercentileColor(p) { /* Unchanged */ }
        function calculateAveragesFromRawData(data) { /* Unchanged */ }
        function getNumericGrade(result) { /* Unchanged */ }
        
        // Full helper functions
        function logToConsole(message, isError = false) { debugConsole.style.display = 'block'; const timestamp = new Date().toLocaleTimeString(); const color = isError ? 'style="color: #e74c3c;"' : ''; debugConsole.innerHTML += `<div>[${timestamp}] <span ${color}>${message}</span></div>`; debugConsole.scrollTop = debugConsole.scrollHeight; (isError ? console.error : console.log)(message); }
        function showError(message) { dashboardContainer.innerHTML = `<div class="error-message">${message}</div>`; logToConsole(message, true); }
        function getPercentileColor(p) { if (p <= 10) return 'var(--success-color)'; if (p <= 25) return 'var(--primary-color)'; if (p <= 50) return '#f39c12'; return 'var(--danger-color)'; }
        function calculateAveragesFromRawData(data) {let termAverages = {GlobalAverage:null, Etape1Average: null, Etape2Average: null, Etape3Average: null}; let allSubjectAverages = {}; let subjectCounts = {}; ['etape1', 'etape2', 'etape3'].forEach(etape => { if (!data[etape]) return; let termSubjectAverages = []; data[etape].forEach(subject => { let subjectTotal = 0, subjectWeight = 0; subject.competencies.forEach(comp => { const compWeightMatch = comp.name.match(/\((\d+)%\)/); if (!compWeightMatch) return; const compWeight = parseFloat(compWeightMatch[1]); let compTotal = 0, compAssignWeight = 0; comp.assignments.forEach(assign => { const grade = getNumericGrade(assign.result); const weight = parseFloat(assign.pond); if (grade !== null && !isNaN(weight) && weight > 0) { compTotal += grade * weight; compAssignWeight += weight; } }); if (compAssignWeight > 0) { subjectTotal += (compTotal / compAssignWeight) * (compWeight / 100); subjectWeight += (compWeight / 100); } }); if (subjectWeight > 0) { const subjectAverage = subjectTotal / subjectWeight; termSubjectAverages.push(subjectAverage); const code = subject.code.substring(0, 3); allSubjectAverages[code] = (allSubjectAverages[code] || 0) + subjectAverage; subjectCounts[code] = (subjectCounts[code] || 0) + 1; } }); if (termSubjectAverages.length > 0) { const etapeKey = 'Etape' + etape.slice(-1) + 'Average'; termAverages[etapeKey] = termSubjectAverages.reduce((a, b) => a + b, 0) / termSubjectAverages.length; } }); for (const code in allSubjectAverages) { allSubjectAverages[code] /= subjectCounts[code]; } let globalTotal = 0, globalWeight = 0; if(termAverages.Etape1Average !== null) {globalTotal += termAverages.Etape1Average * TERM_WEIGHTS.etape1; globalWeight += TERM_WEIGHTS.etape1}; if(termAverages.Etape2Average !== null) {globalTotal += termAverages.Etape2Average * TERM_WEIGHTS.etape2; globalWeight += TERM_WEIGHTS.etape2}; if(termAverages.Etape3Average !== null) {globalTotal += termAverages.Etape3Average * TERM_WEIGHTS.etape3; globalWeight += TERM_WEIGHTS.etape3}; if (globalWeight > 0) termAverages.GlobalAverage = globalTotal / globalWeight; return { term: termAverages, subjects: allSubjectAverages }; }
        function getNumericGrade(result) { if (!result) return null; const gradeMap = {'A+':100,'A':95,'A-':90,'B+':85,'B':80,'B-':75,'C+':70,'C':65,'C-':60,'D+':55,'D':50,'E':45}; const trimmed = result.trim(); if(gradeMap[trimmed]) return gradeMap[trimmed]; const percentageMatch = trimmed.match(/(\d+[,.]?\d*)\s*%/); if (percentageMatch) return parseFloat(percentageMatch[1].replace(',', '.')); const scoreMatch = trimmed.match(/(\d+[,.]?\d*)\s*\/\s*(\d+[,.]?\d*)/); if (scoreMatch) { const score = parseFloat(scoreMatch[1].replace(',', '.')); const max = parseFloat(scoreMatch[2].replace(',', '.')); return (max > 0) ? (score / max) * 100 : null; } const plainNumber = parseFloat(trimmed); if(!isNaN(plainNumber) && plainNumber >=0 && plainNumber <= 110) return plainNumber; return null; }
        function createPerformanceChart(levelData, currentUserData) { const ctx = document.getElementById('performanceChart').getContext('2d'); const calculateGroupAvg = (etapeKey) => { const validGrades = levelData.map(u => parseFloat(u[etapeKey])).filter(g => !isNaN(g) && g > 0); return validGrades.length > 0 ? validGrades.reduce((a,b) => a + b, 0) / validGrades.length : null; }; const parseUserGrade = (grade) => (parseFloat(grade) > 0 ? parseFloat(grade) : null); const userData = [parseUserGrade(currentUserData.Etape1Average), parseUserGrade(currentUserData.Etape2Average), parseUserGrade(currentUserData.Etape3Average)]; const groupData = [calculateGroupAvg('Etape1Average'), calculateGroupAvg('Etape2Average'), calculateGroupAvg('Etape3Average')]; new Chart(ctx, { type: 'line', data: { labels: ['√âtape 1', '√âtape 2', '√âtape 3'], datasets: [{ label: 'Votre Moyenne', data: userData, borderColor: 'rgba(39, 174, 96, 1)', backgroundColor: 'rgba(39, 174, 96, 0.1)', borderWidth: 3, fill: true, tension: 0.4 }, { label: 'Moyenne du Niveau', data: groupData, borderColor: 'rgba(231, 76, 60, 1)', backgroundColor: 'rgba(231, 76, 60, 0.1)', borderWidth: 3, fill: true, tension: 0.4 }] }, options: { responsive: true, scales: { y: { min: 50, max: 100, ticks: { callback: value => `${value}%` } } }, plugins: { legend: { position: 'top' } } } }); }
        function getRank(levelData, key, currentUserEncodedName) { const scores = levelData.map(row => parseFloat(row[key])).filter(score => !isNaN(score)); scores.sort((a, b) => b - a); const currentUser = levelData.find(d => d.encodedName === currentUserEncodedName); const currentUserValue = currentUser ? parseFloat(currentUser[key]) : NaN; const rank = scores.indexOf(currentUserValue) + 1; const percentile = (scores.length > 0) ? (scores.length - rank + 1) / scores.length * 100 : 0; return { rank: rank > 0 ? rank : null, total: scores.length, percentile: rank > 0 ? percentile.toFixed(1) : null }; }
    
    </script>
</body>
</html>
